
‚∏ª

üß© Prompt 1 ‚Äî Cria√ß√£o do TODO.md

Crie um arquivo chamado TODO.md na raiz do projeto mq-probe-api, contendo todo o plano de desenvolvimento por fases, conforme as instru√ß√µes abaixo:

‚∏ª

Conte√∫do do arquivo TODO.md:
	1.	T√≠tulo principal:

# üß≠ MQ Probe ‚Äì Plano de Implementa√ß√£o por Fases


	2.	Bloco de regra de uso:
	‚Ä¢	Explique que a cada fase conclu√≠da deve ser marcada com ‚úÖ no t√≠tulo.
	‚Ä¢	Exemplo:

## ‚úÖ Fase 1 ‚Äî N√∫cleo


	‚Ä¢	Especifique tamb√©m que o desenvolvedor deve marcar as checkboxes conclu√≠das e adicionar uma entrada no CHANGELOG com o resumo da entrega.

	3.	Se√ß√µes de fases:
	‚Ä¢	Fase 0 ‚Äî Funda√ß√£o / Scaffold + DX
	‚Ä¢	Objetivo: criar o esqueleto da aplica√ß√£o Java 17 com Spring Boot 3.x seguindo Clean Architecture + SOLID.
	‚Ä¢	Tarefas: configurar Gradle, depend√™ncias, estrutura de pacotes, health endpoints, Swagger, logging JSON e README.
	‚Ä¢	Fase 1 ‚Äî N√∫cleo (Produce / Consume + Idempot√™ncia)
	‚Ä¢	Objetivo: implementar os endpoints POST /messages/produce e POST /messages/consume com idempot√™ncia via DynamoDB.
	‚Ä¢	Incluir o modelo da tabela mq-probe-idempotency, fluxos, adapters (IBM MQ AllClient), ports, usecases e observabilidade.
	‚Ä¢	Fase 2 ‚Äî Utilidades (Depth, Connectivity, Status, Config)
	‚Ä¢	Objetivo: criar endpoints auxiliares (queue/depth, connections/test, status, version, metrics, config).
	‚Ä¢	Fase 3 ‚Äî Testes Orquestrados e Opera√ß√µes de Lab
	‚Ä¢	Objetivo: permitir testes de carga/soak com endpoints /tests, /queue/purge (atr√°s de feature flag).
	‚Ä¢	Fase 4 ‚Äî Seguran√ßa (AuthN / AuthZ / Hardening)
	‚Ä¢	Objetivo: adicionar OAuth2 Resource Server (JWT) e RBAC/ABAC.
	4.	Checklist (por fase):
	‚Ä¢	Cada fase deve conter checkboxes [ ] para cada tarefa listada.
	‚Ä¢	O desenvolvedor marcar√° [x] ou ‚úÖ conforme as tarefas forem conclu√≠das.
	5.	Se√ß√£o final ‚ÄúRegras de Execu√ß√£o e Qualidade‚Äù
	‚Ä¢	Itens fixos:
	1.	Trabalhar fase por fase.
	2.	Ao finalizar: marcar t√≠tulo com ‚úÖ, ticar checkboxes, e commitar com:

feat(phase): conclu√≠da Fase X - <descri√ß√£o breve>


	3.	Swagger deve estar funcional desde a Fase 0.
	4.	C√≥digo sempre seguindo Clean Architecture + SOLID.
	5.	Sempre usar IBM MQ AllClient.
	6.	Todos os builds e testes devem estar verdes.

‚∏ª

Instru√ß√µes adicionais
	‚Ä¢	O conte√∫do deve ser gerado em formato Markdown completo.
	‚Ä¢	O arquivo final deve ser salvo como TODO.md na raiz do reposit√≥rio.
	‚Ä¢	O texto deve estar em portugu√™s, e usar emojis (‚úÖ, ‚òê) para facilitar visualiza√ß√£o.
	‚Ä¢	Garantir que o arquivo seja leg√≠vel no GitHub (usar t√≠tulos ##, listas e code blocks formatados).

‚∏ª

üëâ Resultado esperado:
Um arquivo TODO.md autoexplicativo, contendo todas as fases do plano do projeto MQ Probe API, com checkboxes, exemplos de commit, e regras para ticar as fases conforme forem implementadas.

‚∏ª

üß© Prompt 2 ‚Äî Fase 0 (Funda√ß√£o / Scaffold + DX)

Crie um projeto Java 17 com Spring Boot 3.x seguindo Clean Architecture + SOLID, separado em camadas api, application, domain, infrastructure. Inclua:
	‚Ä¢	Depend√™ncias Gradle (Kotlin DSL):
	‚Ä¢	spring-boot-starter-web, spring-boot-starter-validation, spring-boot-starter-actuator
	‚Ä¢	micrometer-registry-prometheus
	‚Ä¢	springdoc-openapi-starter-webmvc-ui:2.6.0
	‚Ä¢	com.ibm.mq:com.ibm.mq.allclient:9.3.5.0, jakarta.jms:jakarta.jms-api:3.1.0
	‚Ä¢	software.amazon.awssdk:dynamodb:2.25.40
	‚Ä¢	jackson-databind
	‚Ä¢	testes: spring-boot-starter-test
	‚Ä¢	Estrutura de pacotes:

com.acme.mqprobe/
  api/controller/
  api/dto/
  application/usecase/
  domain/model/
  domain/ports/
  domain/policy/
  infrastructure/mq/
  infrastructure/ddb/
  infrastructure/observability/
  infrastructure/config/

	‚Ä¢	Endpoints apenas health e swagger (por enquanto):
GET /health/live e GET /health/ready (Actuator), Swagger UI habilitado em /swagger-ui.html.
	‚Ä¢	Config padronizada:
	‚Ä¢	application.yaml com server.port=8080, actuator, prometheus.
	‚Ä¢	Logging JSON b√°sico.
	‚Ä¢	Entreg√°veis:
	1.	build.gradle.kts completo.
	2.	Classe MqProbeApplication.java (main).
	3.	Config do SpringDoc/OpenAPI 3.1 habilitado desde j√°.
	4.	README com instru√ß√µes (Gradle bootRun e acesso Swagger/health).

‚∏ª

üß© Prompt 3 ‚Äî Fase 1 (N√∫cleo: Produce / Consume + Idempot√™ncia)

Implemente somente dois endpoints com Swagger/OpenAPI 3.1 e idempot√™ncia em DynamoDB, usando IBM MQ AllClient (JMS).

Requisitos
	‚Ä¢	POST /messages/produce ‚Üí produz lote de mensagens.
	‚Ä¢	POST /messages/consume ‚Üí consome/browse lote de mensagens.
	‚Ä¢	Receber o alvo no body (queueManager, queue, channel, connName, ccdtUrl?, ssl?, auth?).
	‚Ä¢	produce aceita configura√ß√µes de batch, payload, MQ props e headers.
	‚Ä¢	consume aceita maxMessages, waitSeconds, browseOnly, selector, transaction, ack.

Idempot√™ncia (DynamoDB)
	‚Ä¢	Header: Idempotency-Key (UUID) e Idempotency-Expiry-Seconds (opcional).
	‚Ä¢	Tabela mq-probe-idempotency (PAY_PER_REQUEST, TTL, GSIs).
	‚Ä¢	Fluxo:
	1.	Calcula requestHash.
	2.	PutItem condicional PENDING.
	3.	Executa opera√ß√£o MQ.
	4.	Marca SUCCEEDED/FAILED.
	5.	Replay ‚Üí devolve cache.
	6.	Conflito ‚Üí 409.

Clean Architecture
	‚Ä¢	Domain: modelos (Target, BatchConfig, PayloadSpec, MqProps, IdempotencyRecord).
	‚Ä¢	Ports: MessageProducerPort, MessageConsumerPort, IdempotencyRepository.
	‚Ä¢	Application: ProduceMessagesUseCase, ConsumeMessagesUseCase.
	‚Ä¢	Infra: JmsMessageProducerAdapter, JmsMessageConsumerAdapter, DynamoIdempotencyRepository.

API
	‚Ä¢	DTOs ProduceRequest, ConsumeRequest, validados com jakarta.validation.
	‚Ä¢	MessagesController recebe headers de idempot√™ncia.
	‚Ä¢	OpenAPI 3.1 com exemplos.

Observabilidade
	‚Ä¢	Micrometer (mq.produce, mq.consume, mq.idem).
	‚Ä¢	Logs estruturados com traceId, target, requestHash, elapsedMs.

Testes
	‚Ä¢	Unit√°rios e integra√ß√£o m√≠nima JMS/DynamoDB.
	‚Ä¢	README com exemplos curl (produce, consume).

‚∏ª

üß© Prompt 4 ‚Äî Fase 2 (Utilidades: Depth, Connectivity, Status, Config)

Adicionar endpoints auxiliares (sem auth ainda):

Endpoints
	‚Ä¢	POST /queue/depth
	‚Ä¢	POST /connections/test
	‚Ä¢	GET /status
	‚Ä¢	GET /version
	‚Ä¢	GET /metrics
	‚Ä¢	GET /config / PUT /config

Implementa√ß√£o
	‚Ä¢	Reutilizar portas/usecases quando poss√≠vel.
	‚Ä¢	Criar adapter MQ para obter depth via MQINQ/PCF.
	‚Ä¢	OpenAPI com exemplos.

Observabilidade
	‚Ä¢	M√©tricas e histogramas p50/p95/p99.
	‚Ä¢	Logs detalhando sucesso/falha em connections/test.

Entreg√°veis
	‚Ä¢	Endpoints funcionando.
	‚Ä¢	Testes unit√°rios.
	‚Ä¢	README atualizado.

‚∏ª

üß© Prompt 5 ‚Äî Fase 3 (Testes Orquestrados e Opera√ß√µes de Lab)

Adicionar jobs de teste e opera√ß√µes laboratoriais, mantendo Clean Architecture.

Endpoints
	‚Ä¢	POST /tests
	‚Ä¢	GET /tests/{id}
	‚Ä¢	POST /tests/{id}/stop
	‚Ä¢	POST /queue/purge (feature flag)

Implementa√ß√£o
	‚Ä¢	Criar usecases para orquestrar producers/consumers concorrentes.
	‚Ä¢	Exportar m√©tricas por job.
	‚Ä¢	Suportar targetRef (resolved server-side).
	‚Ä¢	Parada graciosa e rate limit.
	‚Ä¢	Testes unit√°rios e README com exemplos.

‚∏ª

üß© Prompt 6 ‚Äî Fase 4 (Seguran√ßa: AuthN / AuthZ / Hardening)

Adicionar OAuth2 JWT + RBAC/ABAC por √∫ltimo.

AuthN
	‚Ä¢	Implementar OAuth2 Resource Server (JWT via JWKS).
	‚Ä¢	Alternativa: x-api-key.

AuthZ
	‚Ä¢	Escopos:
	‚Ä¢	mq:read ‚Üí status, metrics, depth
	‚Ä¢	mq:write ‚Üí produce, consume
	‚Ä¢	mq:admin ‚Üí tests, purge, config
	‚Ä¢	ABAC opcional via targetRef.

Seguran√ßa adicional
	‚Ä¢	Sanitizar logs.
	‚Ä¢	Configurar CORS e headers.
	‚Ä¢	Rate limiting.
	‚Ä¢	Atualizar OpenAPI (securitySchemes).
	‚Ä¢	Testes JWT simulados.
	‚Ä¢	README com instru√ß√µes.

‚∏ª

